<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Parsing: date-time — date-time-parse • clock</title><!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png"><link rel="icon" type="”image/svg+xml”" href="../favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png"><link rel="icon" sizes="any" href="../favicon.ico"><link rel="manifest" href="../site.webmanifest"><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Source_Sans_Pro-0.4.10/font.css" rel="stylesheet"><link href="../deps/Source_Code_Pro-0.4.10/font.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Parsing: date-time — date-time-parse"><meta name="description" content='There are four parsers for parsing strings into POSIXct date-times,
date_time_parse(), date_time_parse_complete(),
date_time_parse_abbrev(), and date_time_parse_RFC_3339().
date_time_parse()


date_time_parse() is useful for strings like "2019-01-01 00:00:00", where
the UTC offset and full time zone name are not present in the string. The
string is first parsed as a naive-time without any time zone assumptions, and
is then converted to a POSIXct with the supplied zone.
Because converting from naive-time to POSIXct may result in nonexistent or
ambiguous times due to daylight saving time, these must be resolved
explicitly with the nonexistent and ambiguous arguments.
date_time_parse() completely ignores the %z and %Z commands. The only
time zone specific information that is used is the zone.
The default format used is "%Y-%m-%d %H:%M:%S". This matches the default
result from calling format() on a POSIXct date-time.



date_time_parse_complete()


date_time_parse_complete() is a parser for complete date-time strings,
like "2019-01-01T00:00:00-05:00[America/New_York]". A complete date-time
string has both the time zone offset and full time zone name in the string,
which is the only way for the string itself to contain all of the information
required to unambiguously construct a zoned-time. Because of this,
date_time_parse_complete() requires both the %z and %Z commands to be
supplied in the format string.
The default format used is "%Y-%m-%dT%H:%M:%S%Ez[%Z]". This matches the
default result from calling date_format() on a POSIXct date-time.
Additionally, this format matches the de-facto standard extension to RFC 3339
for creating completely unambiguous date-times.



date_time_parse_abbrev()


date_time_parse_abbrev() is a parser for date-time strings containing only
a time zone abbreviation, like "2019-01-01 00:00:00 EST". The time zone
abbreviation is not enough to identify the full time zone name that the
date-time belongs to, so the full time zone name must be supplied as the
zone argument. However, the time zone abbreviation can help with resolving
ambiguity around daylight saving time fallbacks.
For date_time_parse_abbrev(), %Z must be supplied and is interpreted as
the time zone abbreviation rather than the full time zone name.
If used, the %z command must parse correctly, but its value will be
completely ignored.
The default format used is "%Y-%m-%d %H:%M:%S %Z". This matches the
default result from calling print() or format(usetz = TRUE) on a POSIXct
date-time.



date_time_parse_RFC_3339()


date_time_parse_RFC_3339() is a parser for date-time strings in the
extremely common date-time format outlined by RFC 3339. This document outlines
a profile of the ISO 8601 format that is even more restrictive, but
corresponds to the most common formats that are likely to be used in
internet protocols (i.e. through APIs).
In particular, this function is intended to parse the following three
formats:
2019-01-01T00:00:00Z
2019-01-01T00:00:00+0430
2019-01-01T00:00:00+04:30

This function defaults to parsing the first of these formats by using
a format string of "%Y-%m-%dT%H:%M:%SZ".
If your date-time strings use offsets from UTC rather than "Z", then set
offset to one of the following:
"%z" if the offset is of the form "+0430".
"%Ez" if the offset is of the form "+04:30".


The RFC 3339 standard allows for replacing the "T" with a "t" or a space
(" "). Set separator to adjust this as needed.
The date-times returned by this function will always be in the UTC time zone.

'><meta property="og:description" content='There are four parsers for parsing strings into POSIXct date-times,
date_time_parse(), date_time_parse_complete(),
date_time_parse_abbrev(), and date_time_parse_RFC_3339().
date_time_parse()


date_time_parse() is useful for strings like "2019-01-01 00:00:00", where
the UTC offset and full time zone name are not present in the string. The
string is first parsed as a naive-time without any time zone assumptions, and
is then converted to a POSIXct with the supplied zone.
Because converting from naive-time to POSIXct may result in nonexistent or
ambiguous times due to daylight saving time, these must be resolved
explicitly with the nonexistent and ambiguous arguments.
date_time_parse() completely ignores the %z and %Z commands. The only
time zone specific information that is used is the zone.
The default format used is "%Y-%m-%d %H:%M:%S". This matches the default
result from calling format() on a POSIXct date-time.



date_time_parse_complete()


date_time_parse_complete() is a parser for complete date-time strings,
like "2019-01-01T00:00:00-05:00[America/New_York]". A complete date-time
string has both the time zone offset and full time zone name in the string,
which is the only way for the string itself to contain all of the information
required to unambiguously construct a zoned-time. Because of this,
date_time_parse_complete() requires both the %z and %Z commands to be
supplied in the format string.
The default format used is "%Y-%m-%dT%H:%M:%S%Ez[%Z]". This matches the
default result from calling date_format() on a POSIXct date-time.
Additionally, this format matches the de-facto standard extension to RFC 3339
for creating completely unambiguous date-times.



date_time_parse_abbrev()


date_time_parse_abbrev() is a parser for date-time strings containing only
a time zone abbreviation, like "2019-01-01 00:00:00 EST". The time zone
abbreviation is not enough to identify the full time zone name that the
date-time belongs to, so the full time zone name must be supplied as the
zone argument. However, the time zone abbreviation can help with resolving
ambiguity around daylight saving time fallbacks.
For date_time_parse_abbrev(), %Z must be supplied and is interpreted as
the time zone abbreviation rather than the full time zone name.
If used, the %z command must parse correctly, but its value will be
completely ignored.
The default format used is "%Y-%m-%d %H:%M:%S %Z". This matches the
default result from calling print() or format(usetz = TRUE) on a POSIXct
date-time.



date_time_parse_RFC_3339()


date_time_parse_RFC_3339() is a parser for date-time strings in the
extremely common date-time format outlined by RFC 3339. This document outlines
a profile of the ISO 8601 format that is even more restrictive, but
corresponds to the most common formats that are likely to be used in
internet protocols (i.e. through APIs).
In particular, this function is intended to parse the following three
formats:
2019-01-01T00:00:00Z
2019-01-01T00:00:00+0430
2019-01-01T00:00:00+04:30

This function defaults to parsing the first of these formats by using
a format string of "%Y-%m-%dT%H:%M:%SZ".
If your date-time strings use offsets from UTC rather than "Z", then set
offset to one of the following:
"%z" if the offset is of the form "+0430".
"%Ez" if the offset is of the form "+04:30".


The RFC 3339 standard allows for replacing the "T" with a "t" or a space
(" "). Set separator to adjust this as needed.
The date-times returned by this function will always be in the UTC time zone.

'><meta property="og:image" content="https://clock.r-lib.org/logo.png"><meta name="robots" content="noindex"><script src="https://cdn.jsdelivr.net/gh/posit-dev/supported-by-posit/js/badge.min.js" data-max-height="43" data-light-bg="#666f76" data-light-fg="#f9f9f9"></script><script defer data-domain="clock.r-lib.org,all.tidyverse.org" src="https://plausible.io/js/plausible.js"></script></head><body>
    <a href="#container" class="visually-hidden-focusable">Skip to content</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-none" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">clock</a>

    <small class="nav-text text-danger me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="In-development version">0.7.3.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="../articles/clock.html">Get started</a></li>
<li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/faq.html">Frequently Asked Questions</a></li>
    <li><a class="dropdown-item" href="../articles/motivations.html">Motivations for clock</a></li>
    <li><a class="dropdown-item" href="../articles/recipes.html">Examples and Recipes</a></li>
  </ul></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-news" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">News</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-news"><li><h6 class="dropdown-header" data-toc-skip>Releases</h6></li>
    <li><a class="external-link dropdown-item" href="https://www.tidyverse.org/blog/2021/03/clock-0-1-0/">Version 0.1.0</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" href="../news/index.html">Changelog</a></li>
  </ul></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/r-lib/clock/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic" id="container">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Parsing: date-time</h1>
      <small class="dont-index">Source: <a href="https://github.com/r-lib/clock/blob/main/R/posixt.R" class="external-link"><code>R/posixt.R</code></a></small>
      <div class="d-none name"><code>date-time-parse.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>There are four parsers for parsing strings into POSIXct date-times,
<code>date_time_parse()</code>, <code>date_time_parse_complete()</code>,
<code>date_time_parse_abbrev()</code>, and <code>date_time_parse_RFC_3339()</code>.</p><div class="section">
<h3 id="date-time-parse-">date_time_parse()<a class="anchor" aria-label="anchor" href="#date-time-parse-"></a></h3>


<p><code>date_time_parse()</code> is useful for strings like <code>"2019-01-01 00:00:00"</code>, where
the UTC offset and full time zone name are not present in the string. The
string is first parsed as a naive-time without any time zone assumptions, and
is then converted to a POSIXct with the supplied <code>zone</code>.</p>
<p>Because converting from naive-time to POSIXct may result in nonexistent or
ambiguous times due to daylight saving time, these must be resolved
explicitly with the <code>nonexistent</code> and <code>ambiguous</code> arguments.</p>
<p><code>date_time_parse()</code> completely ignores the <code>%z</code> and <code>%Z</code> commands. The only
time zone specific information that is used is the <code>zone</code>.</p>
<p>The default <code>format</code> used is <code>"%Y-%m-%d %H:%M:%S"</code>. This matches the default
result from calling <code><a href="https://rdrr.io/r/base/format.html" class="external-link">format()</a></code> on a POSIXct date-time.</p>
</div>

<div class="section">
<h3 id="date-time-parse-complete-">date_time_parse_complete()<a class="anchor" aria-label="anchor" href="#date-time-parse-complete-"></a></h3>


<p><code>date_time_parse_complete()</code> is a parser for <em>complete</em> date-time strings,
like <code>"2019-01-01T00:00:00-05:00[America/New_York]"</code>. A complete date-time
string has both the time zone offset and full time zone name in the string,
which is the only way for the string itself to contain all of the information
required to unambiguously construct a zoned-time. Because of this,
<code>date_time_parse_complete()</code> requires both the <code>%z</code> and <code>%Z</code> commands to be
supplied in the <code>format</code> string.</p>
<p>The default <code>format</code> used is <code>"%Y-%m-%dT%H:%M:%S%Ez[%Z]"</code>. This matches the
default result from calling <code><a href="date_format.html">date_format()</a></code> on a POSIXct date-time.
Additionally, this format matches the de-facto standard extension to RFC 3339
for creating completely unambiguous date-times.</p>
</div>

<div class="section">
<h3 id="date-time-parse-abbrev-">date_time_parse_abbrev()<a class="anchor" aria-label="anchor" href="#date-time-parse-abbrev-"></a></h3>


<p><code>date_time_parse_abbrev()</code> is a parser for date-time strings containing only
a time zone abbreviation, like <code>"2019-01-01 00:00:00 EST"</code>. The time zone
abbreviation is not enough to identify the full time zone name that the
date-time belongs to, so the full time zone name must be supplied as the
<code>zone</code> argument. However, the time zone abbreviation can help with resolving
ambiguity around daylight saving time fallbacks.</p>
<p>For <code>date_time_parse_abbrev()</code>, <code>%Z</code> must be supplied and is interpreted as
the time zone abbreviation rather than the full time zone name.</p>
<p>If used, the <code>%z</code> command must parse correctly, but its value will be
completely ignored.</p>
<p>The default <code>format</code> used is <code>"%Y-%m-%d %H:%M:%S %Z"</code>. This matches the
default result from calling <code><a href="https://rdrr.io/r/base/print.html" class="external-link">print()</a></code> or <code>format(usetz = TRUE)</code> on a POSIXct
date-time.</p>
</div>

<div class="section">
<h3 id="date-time-parse-rfc-">date_time_parse_RFC_3339()<a class="anchor" aria-label="anchor" href="#date-time-parse-rfc-"></a></h3>


<p><code>date_time_parse_RFC_3339()</code> is a parser for date-time strings in the
extremely common date-time format outlined by <a href="https://datatracker.ietf.org/doc/html/rfc3339" class="external-link">RFC 3339</a>. This document outlines
a profile of the ISO 8601 format that is even more restrictive, but
corresponds to the most common formats that are likely to be used in
internet protocols (i.e. through APIs).</p>
<p>In particular, this function is intended to parse the following three
formats:</p>
<p></p><div class="sourceCode"><pre><code><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="dv">2019-01-01</span>T00<span class="sc">:</span><span class="dv">00</span><span class="sc">:</span><span class="dv">00</span>Z</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="dv">2019-01-01</span>T00<span class="sc">:</span><span class="dv">00</span><span class="sc">:</span><span class="dv">00</span><span class="sc">+</span><span class="dv">0430</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="dv">2019-01-01</span>T00<span class="sc">:</span><span class="dv">00</span><span class="sc">:</span><span class="dv">00</span><span class="sc">+</span><span class="dv">04</span><span class="sc">:</span><span class="dv">30</span></span></code></pre><p></p></div>
<p>This function defaults to parsing the first of these formats by using
a format string of <code>"%Y-%m-%dT%H:%M:%SZ"</code>.</p>
<p>If your date-time strings use offsets from UTC rather than <code>"Z"</code>, then set
<code>offset</code> to one of the following:</p><ul><li><p><code>"%z"</code> if the offset is of the form <code>"+0430"</code>.</p></li>
<li><p><code>"%Ez"</code> if the offset is of the form <code>"+04:30"</code>.</p></li>
</ul><p>The RFC 3339 standard allows for replacing the <code>"T"</code> with a <code>"t"</code> or a space
(<code>" "</code>). Set <code>separator</code> to adjust this as needed.</p>
<p>The date-times returned by this function will always be in the UTC time zone.</p>
</div>

    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">date_time_parse</span><span class="op">(</span></span>
<span>  <span class="va">x</span>,</span>
<span>  <span class="va">zone</span>,</span>
<span>  <span class="va">...</span>,</span>
<span>  format <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  locale <span class="op">=</span> <span class="fu"><a href="clock_locale.html">clock_locale</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  nonexistent <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  ambiguous <span class="op">=</span> <span class="cn">NULL</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">date_time_parse_complete</span><span class="op">(</span><span class="va">x</span>, <span class="va">...</span>, format <span class="op">=</span> <span class="cn">NULL</span>, locale <span class="op">=</span> <span class="fu"><a href="clock_locale.html">clock_locale</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">date_time_parse_abbrev</span><span class="op">(</span><span class="va">x</span>, <span class="va">zone</span>, <span class="va">...</span>, format <span class="op">=</span> <span class="cn">NULL</span>, locale <span class="op">=</span> <span class="fu"><a href="clock_locale.html">clock_locale</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">date_time_parse_RFC_3339</span><span class="op">(</span><span class="va">x</span>, <span class="va">...</span>, separator <span class="op">=</span> <span class="st">"T"</span>, offset <span class="op">=</span> <span class="st">"Z"</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-x">x<a class="anchor" aria-label="anchor" href="#arg-x"></a></dt>
<dd><p><code>[character]</code></p>
<p>A character vector to parse.</p></dd>


<dt id="arg-zone">zone<a class="anchor" aria-label="anchor" href="#arg-zone"></a></dt>
<dd><p><code>[character(1)]</code></p>
<p>A full time zone name.</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>These dots are for future extensions and must be empty.</p></dd>


<dt id="arg-format">format<a class="anchor" aria-label="anchor" href="#arg-format"></a></dt>
<dd><p><code>[character / NULL]</code></p>
<p>A format string. A combination of the following commands, or <code>NULL</code>,
in which case a default format string is used.</p>
<p>A vector of multiple format strings can be supplied. They will be tried in
the order they are provided.</p>
<p><strong>Year</strong></p><ul><li><p><code>%C</code>: The century as a decimal number. The modified command <code>%NC</code> where
<code>N</code> is a positive decimal integer specifies the maximum number of
characters to read. If not specified, the default is <code>2</code>. Leading zeroes
are permitted but not required.</p></li>
<li><p><code>%y</code>: The last two decimal digits of the year. If the century is not
otherwise specified (e.g. with <code>%C</code>), values in the range <code>[69 - 99]</code> are
presumed to refer to the years <code>[1969 - 1999]</code>, and values in the range
<code>[00 - 68]</code> are presumed to refer to the years <code>[2000 - 2068]</code>. The
modified command <code>%Ny</code>, where <code>N</code> is a positive decimal integer, specifies
the maximum number of characters to read. If not specified, the default is
<code>2</code>. Leading zeroes are permitted but not required.</p></li>
<li><p><code>%Y</code>: The year as a decimal number. The modified command <code>%NY</code> where <code>N</code>
is a positive decimal integer specifies the maximum number of characters to
read. If not specified, the default is <code>4</code>. Leading zeroes are permitted
but not required.</p></li>
</ul><p><strong>Month</strong></p><ul><li><p><code>%b</code>, <code>%B</code>, <code>%h</code>: The <code>locale</code>'s full or abbreviated case-insensitive
month name.</p></li>
<li><p><code>%m</code>: The month as a decimal number. January is <code>1</code>. The modified command
<code>%Nm</code> where <code>N</code> is a positive decimal integer specifies the maximum number
of characters to read. If not specified, the default is <code>2</code>. Leading zeroes
are permitted but not required.</p></li>
</ul><p><strong>Day</strong></p><ul><li><p><code>%d</code>, <code>%e</code>: The day of the month as a decimal number. The modified
command <code>%Nd</code> where <code>N</code> is a positive decimal integer specifies the maximum
number of characters to read. If not specified, the default is <code>2</code>. Leading
zeroes are permitted but not required.</p></li>
</ul><p><strong>Day of the week</strong></p><ul><li><p><code>%a</code>, <code>%A</code>: The <code>locale</code>'s full or abbreviated case-insensitive weekday
name.</p></li>
<li><p><code>%w</code>: The weekday as a decimal number (<code>0-6</code>), where Sunday is <code>0</code>. The
modified command <code>%Nw</code> where <code>N</code> is a positive decimal integer specifies
the maximum number of characters to read. If not specified, the default is
<code>1</code>. Leading zeroes are permitted but not required.</p></li>
</ul><p><strong>ISO 8601 week-based year</strong></p><ul><li><p><code>%g</code>: The last two decimal digits of the ISO week-based year. The
modified command <code>%Ng</code> where <code>N</code> is a positive decimal integer specifies
the maximum number of characters to read. If not specified, the default is
<code>2</code>. Leading zeroes are permitted but not required.</p></li>
<li><p><code>%G</code>: The ISO week-based year as a decimal number. The modified command
<code>%NG</code> where <code>N</code> is a positive decimal integer specifies the maximum number
of characters to read. If not specified, the default is <code>4</code>. Leading zeroes
are permitted but not required.</p></li>
<li><p><code>%V</code>: The ISO week-based week number as a decimal number. The modified
command <code>%NV</code> where <code>N</code> is a positive decimal integer specifies the maximum
number of characters to read. If not specified, the default is <code>2</code>. Leading
zeroes are permitted but not required.</p></li>
<li><p><code>%u</code>: The ISO weekday as a decimal number (<code>1-7</code>), where Monday is <code>1</code>.
The modified command <code>%Nu</code> where <code>N</code> is a positive decimal integer
specifies the maximum number of characters to read. If not specified, the
default is <code>1</code>. Leading zeroes are permitted but not required.</p></li>
</ul><p><strong>Week of the year</strong></p><ul><li><p><code>%U</code>: The week number of the year as a decimal number. The first Sunday
of the year is the first day of week <code>01</code>. Days of the same year prior to
that are in week <code>00</code>. The modified command <code>%NU</code> where <code>N</code> is a positive
decimal integer specifies the maximum number of characters to read. If not
specified, the default is <code>2</code>. Leading zeroes are permitted but not
required.</p></li>
<li><p><code>%W</code>: The week number of the year as a decimal number. The first Monday
of the year is the first day of week <code>01</code>. Days of the same year prior to
that are in week <code>00</code>. The modified command <code>%NW</code> where <code>N</code> is a positive
decimal integer specifies the maximum number of characters to read. If not
specified, the default is <code>2</code>. Leading zeroes are permitted but not
required.</p></li>
</ul><p><strong>Day of the year</strong></p><ul><li><p><code>%j</code>: The day of the year as a decimal number. January 1 is <code>1</code>. The
modified command <code>%Nj</code> where <code>N</code> is a positive decimal integer specifies
the maximum number of characters to read. If not specified, the default is
<code>3</code>. Leading zeroes are permitted but not required.</p></li>
</ul><p><strong>Date</strong></p><ul><li><p><code>%D</code>, <code>%x</code>: Equivalent to <code>%m/%d/%y</code>.</p></li>
<li><p><code>%F</code>: Equivalent to <code>%Y-%m-%d</code>. If modified with a width (like <code>%NF</code>),
the width is applied to only <code>%Y</code>.</p></li>
</ul><p><strong>Time of day</strong></p><ul><li><p><code>%H</code>: The hour (24-hour clock) as a decimal number. The modified command
<code>%NH</code> where <code>N</code> is a positive decimal integer specifies the maximum number
of characters to read. If not specified, the default is <code>2</code>. Leading zeroes
are permitted but not required.</p></li>
<li><p><code>%I</code>: The hour (12-hour clock) as a decimal number. The modified command
<code>%NI</code> where <code>N</code> is a positive decimal integer specifies the maximum number
of characters to read. If not specified, the default is <code>2</code>. Leading zeroes
are permitted but not required.</p></li>
<li><p><code>%M</code>: The minutes as a decimal number. The modified command <code>%NM</code> where
<code>N</code> is a positive decimal integer specifies the maximum number of
characters to read. If not specified, the default is <code>2</code>. Leading zeroes
are permitted but not required.</p></li>
<li><p><code>%S</code>: The seconds as a decimal number. Leading zeroes are permitted but
not required. If encountered, the <code>locale</code> determines the decimal point
character. Generally, the maximum number of characters to read is
determined by the precision that you are parsing at. For example, a
precision of <code>"second"</code> would read a maximum of 2 characters, while a
precision of <code>"millisecond"</code> would read a maximum of 6 (2 for the values
before the decimal point, 1 for the decimal point, and 3 for the values
after it). The modified command <code>%NS</code>, where <code>N</code> is a positive decimal
integer, can be used to exactly specify the maximum number of characters to
read. This is only useful if you happen to have seconds with more than 1
leading zero.</p></li>
<li><p><code>%p</code>: The <code>locale</code>'s equivalent of the AM/PM designations associated with
a 12-hour clock. The command <code>%I</code> must precede <code>%p</code> in the format string.</p></li>
<li><p><code>%R</code>: Equivalent to <code>%H:%M</code>.</p></li>
<li><p><code>%T</code>, <code>%X</code>: Equivalent to <code>%H:%M:%S</code>.</p></li>
<li><p><code>%r</code>: Equivalent to <code>%I:%M:%S %p</code>.</p></li>
</ul><p><strong>Time zone</strong></p><ul><li><p><code>%z</code>: The offset from UTC in the format <code>[+|-]hh[mm]</code>. For example
<code>-0430</code> refers to 4 hours 30 minutes behind UTC. And <code>04</code> refers to 4 hours
ahead of UTC. The modified command <code>%Ez</code> parses a <code>:</code> between the hours and
minutes and leading zeroes on the hour field are optional:
<code>[+|-]h[h][:mm]</code>. For example <code>-04:30</code> refers to 4 hours 30 minutes behind
UTC. And <code>4</code> refers to 4 hours ahead of UTC.</p></li>
<li><p><code>%Z</code>: The full time zone name or the time zone abbreviation, depending on
the function being used. A single word is parsed. This word can only
contain characters that are alphanumeric, or one of <code>'_'</code>, <code>'/'</code>, <code>'-'</code> or
<code>'+'</code>.</p></li>
</ul><p><strong>Miscellaneous</strong></p><ul><li><p><code>%c</code>: A date and time representation. Equivalent to
<code>%a %b %d %H:%M:%S %Y</code>.</p></li>
<li><p><code>%%</code>: A <code>%</code> character.</p></li>
<li><p><code>%n</code>: Matches one white space character. <code>%n</code>, <code>%t</code>, and a space can be
combined to match a wide range of white-space patterns. For example <code>"%n "</code>
matches one or more white space characters, and <code>"%n%t%t"</code> matches one to
three white space characters.</p></li>
<li><p><code>%t</code>: Matches zero or one white space characters.</p></li>
</ul></dd>


<dt id="arg-locale">locale<a class="anchor" aria-label="anchor" href="#arg-locale"></a></dt>
<dd><p><code>[clock_locale]</code></p>
<p>A locale object created from <code><a href="clock_locale.html">clock_locale()</a></code>.</p></dd>


<dt id="arg-nonexistent">nonexistent<a class="anchor" aria-label="anchor" href="#arg-nonexistent"></a></dt>
<dd><p><code>[character / NULL]</code></p>
<p>One of the following nonexistent time resolution strategies, allowed to be
either length 1, or the same length as the input:</p><ul><li><p><code>"roll-forward"</code>: The next valid instant in time.</p></li>
<li><p><code>"roll-backward"</code>: The previous valid instant in time.</p></li>
<li><p><code>"shift-forward"</code>: Shift the nonexistent time forward by the size of
the daylight saving time gap.</p></li>
<li><p><code>"shift-backward</code>: Shift the nonexistent time backward by the size of
the daylight saving time gap.</p></li>
<li><p><code>"NA"</code>: Replace nonexistent times with <code>NA</code>.</p></li>
<li><p><code>"error"</code>: Error on nonexistent times.</p></li>
</ul><p>Using either <code>"roll-forward"</code> or <code>"roll-backward"</code> is generally
recommended over shifting, as these two strategies maintain the
<em>relative ordering</em> between elements of the input.</p>
<p>If <code>NULL</code>, defaults to <code>"error"</code>.</p>
<p>If <code>getOption("clock.strict")</code> is <code>TRUE</code>, <code>nonexistent</code> must be supplied
and cannot be <code>NULL</code>. This is a convenient way to make production code
robust to nonexistent times.</p></dd>


<dt id="arg-ambiguous">ambiguous<a class="anchor" aria-label="anchor" href="#arg-ambiguous"></a></dt>
<dd><p><code>[character / zoned_time / POSIXct / list(2) / NULL]</code></p>
<p>One of the following ambiguous time resolution strategies, allowed to be
either length 1, or the same length as the input:</p><ul><li><p><code>"earliest"</code>: Of the two possible times, choose the earliest one.</p></li>
<li><p><code>"latest"</code>: Of the two possible times, choose the latest one.</p></li>
<li><p><code>"NA"</code>: Replace ambiguous times with <code>NA</code>.</p></li>
<li><p><code>"error"</code>: Error on ambiguous times.</p></li>
</ul><p>Alternatively, <code>ambiguous</code> is allowed to be a zoned_time (or POSIXct) that
is either length 1, or the same length as the input. If an ambiguous time
is encountered, the zoned_time is consulted. If the zoned_time corresponds
to a naive_time that is also ambiguous <em>and</em> uses the same daylight saving
time transition point as the original ambiguous time, then the offset of
the zoned_time is used to resolve the ambiguity. If the ambiguity cannot be
resolved by consulting the zoned_time, then this method falls back to
<code>NULL</code>.</p>
<p>Finally, <code>ambiguous</code> is allowed to be a list of size 2, where the first
element of the list is a zoned_time (as described above), and the second
element of the list is an ambiguous time resolution strategy to use when
the ambiguous time cannot be resolved by consulting the zoned_time.
Specifying a zoned_time on its own is identical to <code>list(&lt;zoned_time&gt;, NULL)</code>.</p>
<p>If <code>NULL</code>, defaults to <code>"error"</code>.</p>
<p>If <code>getOption("clock.strict")</code> is <code>TRUE</code>, <code>ambiguous</code> must be supplied and
cannot be <code>NULL</code>. Additionally, <code>ambiguous</code> cannot be specified as a
zoned_time on its own, as this implies <code>NULL</code> for ambiguous times that the
zoned_time cannot resolve. Instead, it must be specified as a list
alongside an ambiguous time resolution strategy as described above. This is
a convenient way to make production code robust to ambiguous times.</p></dd>


<dt id="arg-separator">separator<a class="anchor" aria-label="anchor" href="#arg-separator"></a></dt>
<dd><p><code>[character(1)]</code></p>
<p>The separator between the date and time components of the string. One of:</p><ul><li><p><code>"T"</code></p></li>
<li><p><code>"t"</code></p></li>
<li><p><code>" "</code></p></li>
</ul></dd>


<dt id="arg-offset">offset<a class="anchor" aria-label="anchor" href="#arg-offset"></a></dt>
<dd><p><code>[character(1)]</code></p>
<p>The format of the offset from UTC contained in the string. One of:</p><ul><li><p><code>"Z"</code></p></li>
<li><p><code>"z"</code></p></li>
<li><p><code>"%z"</code> to parse a numeric offset of the form <code>"+0430"</code></p></li>
<li><p><code>"%Ez"</code> to parse a numeric offset of the form <code>"+04:30"</code></p></li>
</ul></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>A POSIXct.</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>If <code>date_time_parse_complete()</code> is given input that is length zero, all
<code>NA</code>s, or completely fails to parse, then no time zone will be able to be
determined. In that case, the result will use <code>"UTC"</code>.</p>
<p>If you have strings with sub-second components, then these date-time parsers
are not appropriate for you. Remember that clock treats POSIXct as a second
precision type, so parsing a string with fractional seconds directly into a
POSIXct is ambiguous and undefined. Instead, fully parse the string,
including its fractional seconds, into a clock type that can handle it, such
as a naive-time with <code><a href="naive_time_parse.html">naive_time_parse()</a></code>, then round to seconds with
whatever rounding convention is appropriate for your use case, such as
<code><a href="time-point-rounding.html">time_point_floor()</a></code>, and finally convert that to POSIXct with
<code><a href="as_date_time.html">as_date_time()</a></code>. This gives you complete control over how the fractional
seconds are handled when converting to POSIXct.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co"># Parse with a known `zone`, even though that information isn't in the string</span></span></span>
<span class="r-in"><span><span class="fu">date_time_parse</span><span class="op">(</span><span class="st">"2020-01-01 05:06:07"</span>, <span class="st">"America/New_York"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "2020-01-01 05:06:07 EST"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Same time as above, except this is a completely unambiguous parse that</span></span></span>
<span class="r-in"><span><span class="co"># doesn't require a `zone` argument, because the zone name and offset are</span></span></span>
<span class="r-in"><span><span class="co"># both present in the string</span></span></span>
<span class="r-in"><span><span class="fu">date_time_parse_complete</span><span class="op">(</span><span class="st">"2020-01-01T05:06:07-05:00[America/New_York]"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "2020-01-01 05:06:07 EST"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Only day components</span></span></span>
<span class="r-in"><span><span class="fu">date_time_parse</span><span class="op">(</span><span class="st">"2020-01-01"</span>, <span class="st">"America/New_York"</span>, format <span class="op">=</span> <span class="st">"%Y-%m-%d"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "2020-01-01 EST"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># `date_time_parse()` may have issues with ambiguous times due to daylight</span></span></span>
<span class="r-in"><span><span class="co"># saving time fallbacks. For example, there were two 1'oclock hours here:</span></span></span>
<span class="r-in"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu">date_time_parse</span><span class="op">(</span><span class="st">"1970-10-25 00:59:59"</span>, <span class="st">"America/New_York"</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># First (earliest) 1'oclock hour</span></span></span>
<span class="r-in"><span><span class="fu"><a href="clock-arithmetic.html">add_seconds</a></span><span class="op">(</span><span class="va">x</span>, <span class="fl">1</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "1970-10-25 01:00:00 EDT"</span>
<span class="r-in"><span><span class="co"># Second (latest) 1'oclock hour</span></span></span>
<span class="r-in"><span><span class="fu"><a href="clock-arithmetic.html">add_seconds</a></span><span class="op">(</span><span class="va">x</span>, <span class="fl">3601</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "1970-10-25 01:00:00 EST"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># If you try to parse this ambiguous time directly, you'll get an error:</span></span></span>
<span class="r-in"><span><span class="va">ambiguous_time</span> <span class="op">&lt;-</span> <span class="st">"1970-10-25 01:00:00"</span></span></span>
<span class="r-in"><span><span class="kw"><a href="https://rdrr.io/r/base/try.html" class="external-link">try</a></span><span class="op">(</span><span class="fu">date_time_parse</span><span class="op">(</span><span class="va">ambiguous_time</span>, <span class="st">"America/New_York"</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Error in as_zoned_time(x, zone = tz, nonexistent = nonexistent, ambiguous = ambiguous) : </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   Ambiguous time due to daylight saving time at location 1.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="color: #0000BB;">ℹ</span> Resolve ambiguous time issues by specifying the `ambiguous` argument.</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Resolve it by specifying whether you'd like to use the</span></span></span>
<span class="r-in"><span><span class="co"># `earliest` or `latest` of the two possible times</span></span></span>
<span class="r-in"><span><span class="fu">date_time_parse</span><span class="op">(</span><span class="va">ambiguous_time</span>, <span class="st">"America/New_York"</span>, ambiguous <span class="op">=</span> <span class="st">"earliest"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "1970-10-25 01:00:00 EDT"</span>
<span class="r-in"><span><span class="fu">date_time_parse</span><span class="op">(</span><span class="va">ambiguous_time</span>, <span class="st">"America/New_York"</span>, ambiguous <span class="op">=</span> <span class="st">"latest"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "1970-10-25 01:00:00 EST"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># `date_time_parse_complete()` doesn't have these issues, as it requires</span></span></span>
<span class="r-in"><span><span class="co"># that the offset and zone name are both in the string, which resolves</span></span></span>
<span class="r-in"><span><span class="co"># the ambiguity</span></span></span>
<span class="r-in"><span><span class="va">complete_times</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="st">"1970-10-25T01:00:00-04:00[America/New_York]"</span>,</span></span>
<span class="r-in"><span>  <span class="st">"1970-10-25T01:00:00-05:00[America/New_York]"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu">date_time_parse_complete</span><span class="op">(</span><span class="va">complete_times</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "1970-10-25 01:00:00 EDT" "1970-10-25 01:00:00 EST"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># `date_time_parse_abbrev()` also doesn't have these issues, since it</span></span></span>
<span class="r-in"><span><span class="co"># uses the time zone abbreviation name to resolve the ambiguity</span></span></span>
<span class="r-in"><span><span class="va">abbrev_times</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="st">"1970-10-25 01:00:00 EDT"</span>,</span></span>
<span class="r-in"><span>  <span class="st">"1970-10-25 01:00:00 EST"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu">date_time_parse_abbrev</span><span class="op">(</span><span class="va">abbrev_times</span>, <span class="st">"America/New_York"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "1970-10-25 01:00:00 EDT" "1970-10-25 01:00:00 EST"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># ---------------------------------------------------------------------------</span></span></span>
<span class="r-in"><span><span class="co"># RFC 3339</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Typical UTC format</span></span></span>
<span class="r-in"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="st">"2019-01-01T00:01:02Z"</span></span></span>
<span class="r-in"><span><span class="fu">date_time_parse_RFC_3339</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "2019-01-01 00:01:02 UTC"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># With a UTC offset containing a `:`</span></span></span>
<span class="r-in"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="st">"2019-01-01T00:01:02+02:30"</span></span></span>
<span class="r-in"><span><span class="fu">date_time_parse_RFC_3339</span><span class="op">(</span><span class="va">x</span>, offset <span class="op">=</span> <span class="st">"%Ez"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "2018-12-31 21:31:02 UTC"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># With a space between the date and time and no `:` in the offset</span></span></span>
<span class="r-in"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="st">"2019-01-01 00:01:02+0230"</span></span></span>
<span class="r-in"><span><span class="fu">date_time_parse_RFC_3339</span><span class="op">(</span><span class="va">x</span>, separator <span class="op">=</span> <span class="st">" "</span>, offset <span class="op">=</span> <span class="st">"%z"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "2018-12-31 21:31:02 UTC"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># ---------------------------------------------------------------------------</span></span></span>
<span class="r-in"><span><span class="co"># Sub-second components</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># If you have a string with sub-second components, but only require up to</span></span></span>
<span class="r-in"><span><span class="co"># seconds, first parse them into a clock type that can handle sub-seconds to</span></span></span>
<span class="r-in"><span><span class="co"># fully capture that information, then round using whatever convention is</span></span></span>
<span class="r-in"><span><span class="co"># required for your use case before converting to a date-time.</span></span></span>
<span class="r-in"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"2019-01-01T00:00:01.1"</span>, <span class="st">"2019-01-01T00:00:01.78"</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="naive_time_parse.html">naive_time_parse</a></span><span class="op">(</span><span class="va">x</span>, precision <span class="op">=</span> <span class="st">"millisecond"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">x</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> &lt;naive_time&lt;millisecond&gt;[2]&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "2019-01-01T00:00:01.100" "2019-01-01T00:00:01.780"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu"><a href="time-point-rounding.html">time_point_floor</a></span><span class="op">(</span><span class="va">x</span>, <span class="st">"second"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> &lt;naive_time&lt;second&gt;[2]&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "2019-01-01T00:00:01" "2019-01-01T00:00:01"</span>
<span class="r-in"><span><span class="fu"><a href="time-point-rounding.html">time_point_round</a></span><span class="op">(</span><span class="va">x</span>, <span class="st">"second"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> &lt;naive_time&lt;second&gt;[2]&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "2019-01-01T00:00:01" "2019-01-01T00:00:02"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu"><a href="as_date_time.html">as_date_time</a></span><span class="op">(</span><span class="fu"><a href="time-point-rounding.html">time_point_round</a></span><span class="op">(</span><span class="va">x</span>, <span class="st">"second"</span><span class="op">)</span>, <span class="st">"America/New_York"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "2019-01-01 00:00:01 EST" "2019-01-01 00:00:02 EST"</span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


   </div>
  <footer><div class="container">
  <div class="pkgdown-footer-left">
  <p>Developed by <a href="https://github.com/DavisVaughan" class="external-link">Davis Vaughan</a>, <a href="https://www.posit.co" class="external-link"><img src="https://www.tidyverse.org/posit-logo.svg" alt="Posit" height="16" width="62" style="margin-bottom: 3px;"></a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

  </div></footer></body></html>

